package com.cairns.rich.aoc._2016;

import com.cairns.rich.aoc.Loader;
import com.cairns.rich.aoc.Loader.ConfigToken;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.stream.Collectors;

/**
 * Passwords need to be scrambled and unscrambled.  Each input has a series of instructions.
 */
class Day21 extends Base2016 {
  private static final ConfigToken<String> password = ConfigToken.of("password", Function.identity());

  /**
   * Creates a scrambled version of the configured password based on the input instructions.
   */
  @Override
  protected Object part1(Loader loader) {
    List<Consumer<StringBuilder>> insts = loader.ml(this::parsePart1);
    StringBuilder state = initState(loader);
    insts.forEach((inst) -> inst.accept(state));
    return state;
  }

  /**
   * Unscrambles the configured password based on applying the reverse of the input instructions backwards.
   */
  @Override
  protected Object part2(Loader loader) {
    List<Consumer<StringBuilder>> insts = loader.ml(this::parsePart2);
    StringBuilder state = initState(loader);
    for (int i = insts.size() - 1; i >= 0; --i) {
      insts.get(i).accept(state);
    }
    return state;
  }

  /**
   * Creates a {@link StringBuilder} that represents the initial password.
   * Also verifies characteristics that are required for the algorithms/problem to work.
   */
  private StringBuilder initState(Loader loader) {
    StringBuilder state = new StringBuilder(loader.getConfig(password));
    if (state.length() % 2 != 0) {
      throw fail(state.length() + " is not even");
    }
    if (state.chars().boxed().collect(Collectors.toSet()).size() != state.length()) {
      throw fail("Duplicate letters: " + state);
    }
    return state;
  }

  /**
   * Returns the {@link #part1(Loader)} instruction from the given spec.
   * TODO: reflection test to ensure parse2(parse1(str)) == str
   */
  private Consumer<StringBuilder> parsePart1(String spec) {
    if (spec.startsWith("swap position ")) {
      return swapPosition(spec);
    }
    else if (spec.startsWith("swap letter ")) {
      return swapLetter(spec);
    }
    else if (spec.startsWith("reverse positions ")) {
      return reverse(spec);
    }
    else if (spec.startsWith("rotate left ")) {
      return rotateLeft(spec);
    }
    else if (spec.startsWith("rotate right ")) {
      return rotateRight(spec);
    }
    else if (spec.startsWith("rotate based on position of letter ")) {
      return rotateBased(spec);
    }
    else if (spec.startsWith("move position ")) {
      return move(spec);
    }
    throw fail(spec);
  }

  /**
   * Computes the {@link #part2(Loader)} instruction from the given spec
   * that can reverse the instruction generated by {@link #parsePart1(String)}.
   */
  private Consumer<StringBuilder> parsePart2(String spec) {
    if (spec.startsWith("swap position ")) {
      return swapPosition(spec);
    }
    else if (spec.startsWith("swap letter ")) {
      return swapLetter(spec);
    }
    else if (spec.startsWith("reverse positions ")) {
      return reverse(spec);
    }
    else if (spec.startsWith("rotate left ")) {
      return rotateRight(parseIndex(spec, "rotate left "));
    }
    else if (spec.startsWith("rotate right ")) {
      return rotateLeft(parseIndex(spec, "rotate right "));
    }
    else if (spec.startsWith("rotate based on position of letter ")) {
      return unrotateBased(spec);
    }
    else if (spec.startsWith("move position ")) {
      return unmove(spec);
    }
    throw fail(spec);
  }

  /**
   * Creates an instruction that swaps two letters at the corresponding spec indexes.
   */
  private Consumer<StringBuilder> swapPosition(String spec) {
    int index1 = parseIndex(spec, "swap position ");
    int index2 = parseIndex(spec, "swap position . with position ");
    return (state) -> {
      char ch1 = state.charAt(index1);
      char ch2 = state.charAt(index2);
      state.setCharAt(index1, ch2);
      state.setCharAt(index2, ch1);
    };
  }

  /**
   * Creates an instruction that swaps the two letters in the corresponding spec.
   */
  private Consumer<StringBuilder> swapLetter(String spec) {
    String letter1 = parseVal(spec, "swap letter ");
    String letter2 = parseVal(spec, "swap letter . with letter ");
    return (state) -> {
      int letter1Index = state.indexOf(letter1);
      int letter2Index = state.indexOf(letter2);
      state.setCharAt(letter1Index, letter2.charAt(0));
      state.setCharAt(letter2Index, letter1.charAt(0));
    };
  }

  /**
   * Creates an instruction that reverses the letters between (inclusive) the two indexes in the corresponding spec.
   */
  private Consumer<StringBuilder> reverse(String spec) {
    int index1 = parseIndex(spec, "reverse positions ");
    int index2 = parseIndex(spec, "reverse positions . through ");
    return (state) -> {
      StringBuilder reverser = new StringBuilder(state.substring(index1, index2 + 1));
      state.replace(index1, index2 + 1, reverser.reverse().toString());
    };
  }

  /**
   * Creates an instruction that rotates the whole string the number of steps in the spec to the left.
   */
  private Consumer<StringBuilder> rotateLeft(String spec) {
    return rotateLeft(parseIndex(spec, "rotate left "));
  }

  /**
   * Creates an instruction that rotates the whole string the given number of unmoded steps to the left.
   */
  private Consumer<StringBuilder> rotateLeft(int unmodedNumSteps) {
    return (state) -> {
      int numSteps = unmodedNumSteps % state.length();
      String leftSide = state.substring(0, numSteps);
      state.replace(0, numSteps, "");
      state.append(leftSide);
    };
  }

  /**
   * Creates an instruction that rotates the whole string the number of steps in the spec to the right.
   */
  private Consumer<StringBuilder> rotateRight(String spec) {
    return rotateRight(parseIndex(spec, "rotate right "));
  }

  /**
   * Creates an instruction that rotates the whole string the given number of unmoded steps to the right.
   */
  private Consumer<StringBuilder> rotateRight(int unmodedNumSteps) {
    return (state) -> {
      int numSteps = unmodedNumSteps % state.length();
      String rightSide = state.substring(state.length() - numSteps);
      state.replace(state.length() - numSteps, state.length(), "");
      state.insert(0, rightSide);
    };
  }

  /**
   * Creates an instruction that rotates based on the position of the letter in the corresponding spec.
   * This is equivalent to a {@link #rotateRight(int)} where the magnitude is computed based on the position
   * of the letter in the spec, plus one, plus another one if the index is greater than or equal to 4.
   */
  private Consumer<StringBuilder> rotateBased(String spec) {
    String basedOn = parseVal(spec, "rotate based on position of letter ");
    return (state) -> {
      int indexOf = state.indexOf(basedOn);
      rotateRight(1 + indexOf + ((indexOf >= state.length() / 2) ? 1 : 0)).accept(state);
    };
  }

  /**
   * Creates an instruction that reverses the {@link #rotateBased(String)}.
   */
  private Consumer<StringBuilder> unrotateBased(String spec) {
    String basedOn = parseVal(spec, "rotate based on position of letter ");
    return (state) -> {
      int currentIndex = state.indexOf(basedOn);
      rotateLeft(computeUnrotateBasedLeftMagnitude(state, currentIndex)).accept(state);
    };
  }

  /**
   * Computes the magnitude we need to {@link #rotateLeft(int)} to reverse a {@link #rotateBased(String)}.
   *   - if the currentIndex is 0, we rotate left 1
   *   - if the currentIndex is odd, we rotate left (current + 1) / 2
   *   - if the currentIndex is even, we rotate left (current + 2 + length) / 2
   */
  private int computeUnrotateBasedLeftMagnitude(StringBuilder state, int currentIndex) {
    if (currentIndex == 0) {
      return 1;
    }
    if (currentIndex % 2 == 1) {
      return (currentIndex + 1) / 2;
    }
    return (currentIndex + 2 + state.length()) / 2;
  }

  /**
   * Creates an instruction that moves the letter at the first index such that it ends in the second index of the spec.
   */
  private Consumer<StringBuilder> move(String spec) {
    int index1 = parseIndex(spec, "move position ");
    int index2 = parseIndex(spec, "move position . to position ");
    return move(index1, index2);
  }

  /**
   * Creates an instruction that moves the letter at the first index such that it ends in the second index.
   */
  private Consumer<StringBuilder> move(int index1, int index2) {
    return (state) -> {
      String moving = state.substring(index1, index1 + 1);
      state.replace(index1, index1 + 1, "");
      state.insert(index2, moving);
    };
  }

  /**
   * Creates an instruction that reverses the {@link #move(String)}.
   */
  private Consumer<StringBuilder> unmove(String spec) {
    int index1 = parseIndex(spec, "move position ");
    int index2 = parseIndex(spec, "move position . to position ");
    return move(index2, index1);
  }

  /**
   * Parses a single character value at the given prefix length's position.
   */
  private String parseVal(String spec, String prefix) {
    int pos = prefix.length();
    return spec.substring(pos, pos + 1);
  }

  /**
   * Parses a single digit integer index from the given spec string after the given prefix.
   * Note that the prefix is just used to determine a length.
   */
  private int parseIndex(String spec, String prefix) {
    return Integer.parseInt(parseVal(spec, prefix));
  }
}
